import re
from collections.abc import Iterable, Iterator
from typing import Any, ClassVar
from typing_extensions import Self

from .connections import Connection

RE_INSERT_VALUES: re.Pattern[str]

class Cursor:
    """
    This is the object used to interact with the database.

    Do not create an instance of a Cursor yourself. Call
    connections.Connection.cursor().

    See `Cursor <https://www.python.org/dev/peps/pep-0249/#cursor-objects>`_ in
    the specification.
    """

    max_stmt_length: ClassVar[int]
    connection: Connection[Any]
    description: tuple[str, ...]
    rownumber: int
    rowcount: int
    arraysize: int
    messages: Any
    errorhandler: Any
    lastrowid: int
    def __init__(self, connection: Connection[Any]) -> None: ...
    def close(self) -> None:
        """
        Closing a cursor just exhausts all remaining data.
        """

    def setinputsizes(self, *args) -> None:
        """Does nothing, required by DB API."""

    def setoutputsizes(self, *args) -> None:
        """Does nothing, required by DB API."""

    def nextset(self) -> bool | None: ...
    def mogrify(self, query: str, args: object = None) -> str:
        """
        Returns the exact string that would be sent to the database by calling the
        execute() method.

        :param query: Query to mogrify.
        :type query: str

        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict

        :return: The query with argument binding applied.
        :rtype: str

        This method follows the extension to the DB API 2.0 followed by Psycopg.
        """

    def execute(self, query: str, args: object = None) -> int:
        """Execute a query.

        :param query: Query to execute.
        :type query: str

        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict

        :return: Number of affected rows.
        :rtype: int

        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """

    def executemany(self, query: str, args: Iterable[object]) -> int | None:
        """Run several data against one query.

        :param query: Query to execute.
        :type query: str

        :param args: Sequence of sequences or mappings. It is used as parameter.
        :type args: tuple or list

        :return: Number of rows affected, if any.
        :rtype: int or None

        This method improves performance on multiple-row INSERT and
        REPLACE. Otherwise it is equivalent to looping over args with
        execute().
        """

    def callproc(self, procname: str, args: Iterable[Any] = ()) -> Any:
        """Execute stored procedure procname with args.

        :param procname: Name of procedure to execute on server.
        :type procname: str

        :param args: Sequence of parameters to use with procedure.
        :type args: tuple or list

        Returns the original args.

        Compatibility warning: PEP-249 specifies that any modified
        parameters must be returned. This is currently impossible
        as they are only available by storing them in a server
        variable and then retrieved by a query. Since stored
        procedures return zero or more result sets, there is no
        reliable way to get at OUT or INOUT parameters via callproc.
        The server variables are named @_procname_n, where procname
        is the parameter above and n is the position of the parameter
        (from zero). Once all result sets generated by the procedure
        have been fetched, you can issue a SELECT @_procname_0, ...
        query using .execute() to get any OUT or INOUT values.

        Compatibility warning: The act of calling a stored procedure
        itself creates an empty result set. This appears after any
        result sets generated by the procedure. This is non-standard
        behavior with respect to the DB-API. Be sure to use nextset()
        to advance through all result sets; otherwise you may get
        disconnected.
        """

    def scroll(self, value: int, mode: str = "relative") -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(self, *exc_info: object) -> None: ...
    # Methods returning result tuples are below.
    def fetchone(self) -> tuple[Any, ...] | None:
        """Fetch the next row."""

    def fetchmany(self, size: int | None = None) -> tuple[tuple[Any, ...], ...]:
        """Fetch several rows."""

    def fetchall(self) -> tuple[tuple[Any, ...], ...]:
        """Fetch all the rows."""

    def __iter__(self) -> Iterator[tuple[Any, ...]]: ...
    def __next__(self): ...

class DictCursorMixin:
    dict_type: Any  # TODO: add support if someone needs this
    def fetchone(self) -> dict[str, Any] | None: ...
    def fetchmany(self, size: int | None = ...) -> tuple[dict[str, Any], ...]: ...
    def fetchall(self) -> tuple[dict[str, Any], ...]: ...
    def __iter__(self) -> Iterator[dict[str, Any]]: ...

class SSCursor(Cursor):
    """
    Unbuffered Cursor, mainly useful for queries that return a lot of data,
    or for connections to remote servers over a slow network.

    Instead of copying every row of data into a buffer, this will fetch
    rows as needed. The upside of this is the client uses much less memory,
    and rows are returned much faster when traveling over a slow network
    or if the result set is very big.

    There are limitations, though. The MySQL protocol doesn't support
    returning the total number of rows, so the only way to tell how many rows
    there are is to iterate over every row returned. Also, it currently isn't
    possible to scroll backwards, as only the current row is held in memory.
    """

    def __del__(self) -> None: ...
    def read_next(self):
        """Read next row."""

    def fetchall(self) -> list[tuple[Any, ...]]:  # type: ignore[override]
        """
        Fetch all, as per MySQLdb. Pretty useless for large queries, as
        it is buffered. See fetchall_unbuffered(), if you want an unbuffered
        generator version of this method.
        """

    def fetchall_unbuffered(self) -> Iterator[tuple[Any, ...]]:
        """
        Fetch all, implemented as a generator, which isn't to standard,
        however, it doesn't make sense to return everything in a list, as that
        would use ridiculous memory for large result sets.
        """

    def scroll(self, value: int, mode: str = "relative") -> None: ...

class DictCursor(DictCursorMixin, Cursor):  # type: ignore[misc]
    """A cursor which returns results as a dictionary"""

class SSDictCursor(DictCursorMixin, SSCursor):  # type: ignore[misc]
    """An unbuffered cursor, which returns results as a dictionary"""

    def fetchall_unbuffered(self) -> Iterator[dict[str, Any]]:  # type: ignore[override]
        """
        Fetch all, implemented as a generator, which isn't to standard,
        however, it doesn't make sense to return everything in a list, as that
        would use ridiculous memory for large result sets.
        """
