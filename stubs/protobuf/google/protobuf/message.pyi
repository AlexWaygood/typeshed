"""Contains an abstract base class for protocol messages."""

from collections.abc import Sequence
from typing import Any
from typing_extensions import Self

from google._upb._message import Descriptor as _upb_Descriptor

from .descriptor import Descriptor, FieldDescriptor
from .internal.extension_dict import _ExtensionDict, _ExtensionFieldDescriptor

class Error(Exception):
    """Base error type for this module."""

class DecodeError(Error):
    """Exception raised when deserializing messages."""

class EncodeError(Error):
    """Exception raised when serializing messages."""

class Message:
    """Abstract base class for protocol messages.

    Protocol message classes are almost always generated by the protocol
    compiler.  These generated types subclass Message and implement the methods
    shown below.
    """

    DESCRIPTOR: Descriptor | _upb_Descriptor
    def __deepcopy__(self, memo: Any = None) -> Self: ...
    def __eq__(self, other_msg):
        """Recursively compares two messages by value and structure."""

    def __ne__(self, other_msg): ...
    def MergeFrom(self, other_msg: Self) -> None:
        """Merges the contents of the specified message into current message.

        This method merges the contents of the specified message into the current
        message. Singular fields that are set in the specified message overwrite
        the corresponding fields in the current message. Repeated fields are
        appended. Singular sub-messages and groups are recursively merged.

        Args:
          other_msg (Message): A message to merge into the current message.
        """

    def CopyFrom(self, other_msg: Self) -> None:
        """Copies the content of the specified message into the current message.

        The method clears the current message and then merges the specified
        message using MergeFrom.

        Args:
          other_msg (Message): A message to copy into the current one.
        """

    def Clear(self) -> None:
        """Clears all data that was set in the message."""

    def SetInParent(self) -> None:
        """Mark this as present in the parent.

        This normally happens automatically when you assign a field of a
        sub-message, but sometimes you want to make the sub-message
        present while keeping it empty.  If you find yourself using this,
        you may want to reconsider your design.
        """

    def IsInitialized(self) -> bool:
        """Checks if the message is initialized.

        Returns:
          bool: The method returns True if the message is initialized (i.e. all of
          its required fields are set).
        """

    def MergeFromString(self, serialized: bytes) -> int:
        """Merges serialized protocol buffer data into this message.

        When we find a field in `serialized` that is already present
        in this message:

        -   If it's a "repeated" field, we append to the end of our list.
        -   Else, if it's a scalar, we overwrite our field.
        -   Else, (it's a nonrepeated composite), we recursively merge
            into the existing composite.

        Args:
          serialized (bytes): Any object that allows us to call
            ``memoryview(serialized)`` to access a string of bytes using the
            buffer interface.

        Returns:
          int: The number of bytes read from `serialized`.
          For non-group messages, this will always be `len(serialized)`,
          but for messages which are actually groups, this will
          generally be less than `len(serialized)`, since we must
          stop when we reach an ``END_GROUP`` tag.  Note that if
          we *do* stop because of an ``END_GROUP`` tag, the number
          of bytes returned does not include the bytes
          for the ``END_GROUP`` tag information.

        Raises:
          DecodeError: if the input cannot be parsed.
        """

    def ParseFromString(self, serialized: bytes) -> int:
        """Parse serialized protocol buffer data in binary form into this message.

        Like :func:`MergeFromString()`, except we clear the object first.

        Raises:
          message.DecodeError if the input cannot be parsed.
        """

    def SerializeToString(self, *, deterministic: bool = ...) -> bytes:
        """Serializes the protocol message to a binary string.

        Keyword Args:
          deterministic (bool): If true, requests deterministic serialization
            of the protobuf, with predictable ordering of map keys.

        Returns:
          A binary string representation of the message if all of the required
          fields in the message are set (i.e. the message is initialized).

        Raises:
          EncodeError: if the message isn't initialized (see :func:`IsInitialized`).
        """

    def SerializePartialToString(self, *, deterministic: bool = ...) -> bytes:
        """Serializes the protocol message to a binary string.

        This method is similar to SerializeToString but doesn't check if the
        message is initialized.

        Keyword Args:
          deterministic (bool): If true, requests deterministic serialization
            of the protobuf, with predictable ordering of map keys.

        Returns:
          bytes: A serialized representation of the partial message.
        """

    def ListFields(self) -> Sequence[tuple[FieldDescriptor, Any]]:
        """Returns a list of (FieldDescriptor, value) tuples for present fields.

        A message field is non-empty if HasField() would return true. A singular
        primitive field is non-empty if HasField() would return true in proto2 or it
        is non zero in proto3. A repeated field is non-empty if it contains at least
        one element. The fields are ordered by field number.

        Returns:
          list[tuple(FieldDescriptor, value)]: field descriptors and values
          for all fields in the message which are not empty. The values vary by
          field type.
        """

    def HasExtension(self, field_descriptor: _ExtensionFieldDescriptor[Self, Any]) -> bool:
        """Checks if a certain extension is present for this message.

        Extensions are retrieved using the :attr:`Extensions` mapping (if present).

        Args:
          field_descriptor: The field descriptor for the extension to check.

        Returns:
          bool: Whether the extension is present for this message.

        Raises:
          KeyError: if the extension is repeated. Similar to repeated fields,
            there is no separate notion of presence: a "not present" repeated
            extension is an empty list.
        """

    def ClearExtension(self, field_descriptor: _ExtensionFieldDescriptor[Self, Any]) -> None:
        """Clears the contents of a given extension.

        Args:
          field_descriptor: The field descriptor for the extension to clear.
        """
    # The TypeVar must be bound to `Message` or we get mypy errors, so we cannot use `Self` for `Extensions`
    @property
    def Extensions(self) -> _ExtensionDict[Self]: ...
    def ByteSize(self) -> int:
        """Returns the serialized size of this message.

        Recursively calls ByteSize() on all contained messages.

        Returns:
          int: The number of bytes required to serialize this message.
        """

    @classmethod
    def FromString(cls, s: bytes) -> Self: ...
    # Intentionally left out typing on these three methods, because they are
    # stringly typed and it is not useful to call them on a Message directly.
    # We prefer more specific typing on individual subclasses of Message
    # See https://github.com/dropbox/mypy-protobuf/issues/62 for details
    def HasField(self, field_name: Any) -> bool:
        """Checks if a certain field is set for the message.

        For a oneof group, checks if any field inside is set. Note that if the
        field_name is not defined in the message descriptor, :exc:`ValueError` will
        be raised.

        Args:
          field_name (str): The name of the field to check for presence.

        Returns:
          bool: Whether a value has been set for the named field.

        Raises:
          ValueError: if the `field_name` is not a member of this message.
        """

    def ClearField(self, field_name: Any) -> None:
        """Clears the contents of a given field.

        Inside a oneof group, clears the field set. If the name neither refers to a
        defined field or oneof group, :exc:`ValueError` is raised.

        Args:
          field_name (str): The name of the field to check for presence.

        Raises:
          ValueError: if the `field_name` is not a member of this message.
        """

    def WhichOneof(self, oneof_group: Any) -> Any:
        """Returns the name of the field that is set inside a oneof group.

        If no field is set, returns None.

        Args:
          oneof_group (str): the name of the oneof group to check.

        Returns:
          str or None: The name of the group that is set, or None.

        Raises:
          ValueError: no group with the given name exists
        """
    # TODO: check kwargs
    def __init__(self, *args, **kwargs) -> None: ...
