"""
Implementation of an SSH2 "message".
"""

from _typeshed import ReadableBuffer
from collections.abc import Iterable
from io import BytesIO
from typing import Any, Protocol
from typing_extensions import TypeAlias

class _SupportsAsBytes(Protocol):
    def asbytes(self) -> bytes: ...

_LikeBytes: TypeAlias = bytes | str | _SupportsAsBytes | ReadableBuffer

class Message:
    """
    An SSH2 message is a stream of bytes that encodes some combination of
    strings, integers, bools, and infinite-precision integers.  This class
    builds or breaks down such a byte stream.

    Normally you don't need to deal with anything this low-level, but it's
    exposed for people implementing custom extensions, or features that
    paramiko doesn't support yet.
    """

    big_int: int
    packet: BytesIO
    seqno: int  # only when packet.Packetizer.read_message() is used
    def __init__(self, content: ReadableBuffer | None = None) -> None:
        """
        Create a new SSH2 message.

        :param bytes content:
            the byte stream to use as the message content (passed in only when
            decomposing a message).
        """

    def __bytes__(self) -> bytes: ...
    def asbytes(self) -> bytes:
        """
        Return the byte stream content of this Message, as a `bytes`.
        """

    def rewind(self) -> None:
        """
        Rewind the message to the beginning as if no items had been parsed
        out of it yet.
        """

    def get_remainder(self) -> bytes:
        """
        Return the `bytes` of this message that haven't already been parsed and
        returned.
        """

    def get_so_far(self) -> bytes:
        """
        Returns the `bytes` of this message that have been parsed and
        returned. The string passed into a message's constructor can be
        regenerated by concatenating ``get_so_far`` and `get_remainder`.
        """

    def get_bytes(self, n: int) -> bytes:
        """
        Return the next ``n`` bytes of the message, without decomposing into an
        int, decoded string, etc.  Just the raw bytes are returned. Returns a
        string of ``n`` zero bytes if there weren't ``n`` bytes remaining in
        the message.
        """

    def get_byte(self) -> bytes:
        """
        Return the next byte of the message, without decomposing it.  This
        is equivalent to `get_bytes(1) <get_bytes>`.

        :return:
            the next (`bytes`) byte of the message, or ``b'\x00'`` if there
            aren't any bytes remaining.
        """

    def get_boolean(self) -> bool:
        """
        Fetch a boolean from the stream.
        """

    def get_adaptive_int(self) -> int:
        """
        Fetch an int from the stream.

        :return: a 32-bit unsigned `int`.
        """

    def get_int(self) -> int:
        """
        Fetch an int from the stream.
        """

    def get_int64(self) -> int:
        """
        Fetch a 64-bit int from the stream.

        :return: a 64-bit unsigned integer (`int`).
        """

    def get_mpint(self) -> int:
        """
        Fetch a long int (mpint) from the stream.

        :return: an arbitrary-length integer (`int`).
        """

    def get_string(self) -> bytes:
        """
        Fetch a "string" from the stream.  This will actually be a `bytes`
        object, and may contain unprintable characters.  (It's not unheard of
        for a string to contain another byte-stream message.)
        """

    def get_text(self) -> str:
        """
        Fetch a Unicode string from the stream.

        This currently operates by attempting to encode the next "string" as
        ``utf-8``.
        """

    def get_binary(self) -> bytes:
        """
        Alias for `get_string` (obtains a bytestring).
        """

    def get_list(self) -> list[str]:
        """
        Fetch a list of `strings <str>` from the stream.

        These are trivially encoded as comma-separated values in a string.
        """

    def add_bytes(self, b: ReadableBuffer) -> Message:
        """
        Write bytes to the stream, without any formatting.

        :param bytes b: bytes to add
        """

    def add_byte(self, b: ReadableBuffer) -> Message:
        """
        Write a single byte to the stream, without any formatting.

        :param bytes b: byte to add
        """

    def add_boolean(self, b: bool) -> Message:
        """
        Add a boolean value to the stream.

        :param bool b: boolean value to add
        """

    def add_int(self, n: int) -> Message:
        """
        Add an integer to the stream.

        :param int n: integer to add
        """

    def add_adaptive_int(self, n: int) -> Message:
        """
        Add an integer to the stream.

        :param int n: integer to add
        """

    def add_int64(self, n: int) -> Message:
        """
        Add a 64-bit int to the stream.

        :param int n: long int to add
        """

    def add_mpint(self, z: int) -> Message:
        """
        Add a long int to the stream, encoded as an infinite-precision
        integer.  This method only works on positive numbers.

        :param int z: long int to add
        """

    def add_string(self, s: _LikeBytes) -> Message:
        """
        Add a bytestring to the stream.

        :param byte s: bytestring to add
        """

    def add_list(self, l: Iterable[str]) -> Message:
        """
        Add a list of strings to the stream.  They are encoded identically to
        a single string of values separated by commas.  (Yes, really, that's
        how SSH2 does it.)

        :param l: list of strings to add
        """

    def add(self, *seq: Any) -> None:
        """
        Add a sequence of items to the stream.  The values are encoded based
        on their type: bytes, str, int, bool, or list.

        .. warning::
            Longs are encoded non-deterministically.  Don't use this method.

        :param seq: the sequence of items
        """
