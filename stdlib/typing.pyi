import abc, collections  # noqa: F401

Any = object()

class TypeVar: ...
class _SpecialForm: ...

_F = TypeVar("_F", bound=Callable[..., Any])
_T = TypeVar("_T")

def overload(func: _F) -> _F: ...

Union: _SpecialForm
Generic: _SpecialForm
Protocol: _SpecialForm
Callable: _SpecialForm
Type: _SpecialForm
NoReturn: _SpecialForm
ClassVar: _SpecialForm
Optional: _SpecialForm
Tuple: _SpecialForm
Final: _SpecialForm

def final(f: _T) -> _T: ...

Literal: _SpecialForm
TypedDict: object
Self: _SpecialForm
Never: _SpecialForm
Unpack: _SpecialForm
Required: _SpecialForm
NotRequired: _SpecialForm
LiteralString: _SpecialForm

class TypeVarTuple: ...
class ParamSpec: ...

Concatenate: _SpecialForm
TypeAlias: _SpecialForm
TypeGuard: _SpecialForm

class NewType:
    def __init__(self, name: str, tp: Any) -> None: ...
    def __call__(self, __x: _T) -> _T: ...
    def __or__(self, other: Any) -> _SpecialForm: ...
    def __ror__(self, other: Any) -> _SpecialForm: ...
    __supertype__: type

_S = TypeVar("_S")
_KT = TypeVar("_KT")  # Key type.
_VT = TypeVar("_VT")  # Value type.
_T_co = TypeVar("_T_co", covariant=True)  # Any type covariant containers.
_KT_co = TypeVar("_KT_co", covariant=True)  # Key type covariant containers.
_VT_co = TypeVar("_VT_co", covariant=True)  # Value type covariant containers.
_TC = TypeVar("_TC", bound=Type[object])

def no_type_check(arg: _F) -> _F: ...

class _Alias:
    def __getitem__(self, typeargs: Any) -> Any: ...

AnyStr = TypeVar("AnyStr", str, bytes)  # noqa: Y001

def runtime_checkable(cls: _TC) -> _TC: ...

class SupportsInt(Protocol):
    def __int__(self) -> int: ...

class SupportsFloat(Protocol):
    def __float__(self) -> float: ...

class SupportsBytes(Protocol):
    def __bytes__(self) -> bytes: ...

class SupportsIndex(Protocol):
    def __index__(self) -> int: ...

class SupportsAbs(Protocol[_T_co]):
    def __abs__(self) -> _T_co: ...

class SupportsRound(Protocol[_T_co]):
    @overload
    def __round__(self) -> int: ...
    @overload
    def __round__(self, __ndigits: int) -> _T_co: ...

class Sized(Protocol):
    def __len__(self) -> int: ...

class Hashable(Protocol):
    def __hash__(self) -> int: ...

class Iterable(Protocol[_T_co]):
    def __iter__(self) -> Iterator[_T_co]: ...

class Iterator(Iterable[_T_co], Protocol[_T_co]):
    def __next__(self) -> _T_co: ...
    def __iter__(self) -> Iterator[_T_co]: ...

class Reversible(Iterable[_T_co], Protocol[_T_co]):
    def __reversed__(self) -> Iterator[_T_co]: ...

_YieldT_co = TypeVar("_YieldT_co", covariant=True)
_SendT_contra = TypeVar("_SendT_contra", contravariant=True)
_ReturnT_co = TypeVar("_ReturnT_co", covariant=True)

class Generator(Iterator[_YieldT_co], Generic[_YieldT_co, _SendT_contra, _ReturnT_co]):
    def __next__(self) -> _YieldT_co: ...
    def send(self, __value: _SendT_contra) -> _YieldT_co: ...
    def close(self) -> None: ...
    def __iter__(self) -> Generator[_YieldT_co, _SendT_contra, _ReturnT_co]: ...

class Awaitable(Protocol[_T_co]):
    def __await__(self) -> Generator[Any, None, _T_co]: ...

class Coroutine(Awaitable[_ReturnT_co], Generic[_YieldT_co, _SendT_contra, _ReturnT_co]):
    def __await__(self) -> Generator[Any, None, _T_co]: ...

class AwaitableGenerator(
    Awaitable[_ReturnT_co],
    Generator[_YieldT_co, _SendT_contra, _ReturnT_co],
    Generic[_YieldT_co, _SendT_contra, _ReturnT_co, _S],
): ...

class AsyncIterable(Protocol[_T_co]):
    def __aiter__(self) -> AsyncIterator[_T_co]: ...

class AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):
    def __anext__(self) -> Awaitable[_T_co]: ...
    def __aiter__(self) -> AsyncIterator[_T_co]: ...

class AsyncGenerator(AsyncIterator[_YieldT_co], Generic[_YieldT_co, _SendT_contra]):
    def __anext__(self) -> Awaitable[_YieldT_co]: ...

class Container(Protocol[_T_co]):
    def __contains__(self, __x: object) -> bool: ...

class Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):
    def __len__(self) -> int: ...

class Sequence(Collection[_T_co], Reversible[_T_co]):
    @overload
    def __getitem__(self, index: int) -> _T_co: ...
    @overload
    def __getitem__(self, index: slice) -> Sequence[_T_co]: ...
    def index(self, value: Any, start: int = 0, stop: int = ...) -> int: ...
    def count(self, value: Any) -> int: ...
    def __contains__(self, value: object) -> bool: ...
    def __iter__(self) -> Iterator[_T_co]: ...
    def __reversed__(self) -> Iterator[_T_co]: ...

class MutableSequence(Sequence[_T]):
    def insert(self, index: int, value: _T) -> None: ...
    @overload
    def __getitem__(self, index: int) -> _T: ...
    @overload
    def __getitem__(self, index: slice) -> MutableSequence[_T]: ...
    @overload
    def __setitem__(self, index: int, value: _T) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: Iterable[_T]) -> None: ...
    @overload
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __delitem__(self, index: slice) -> None: ...
    def append(self, value: _T) -> None: ...
    def clear(self) -> None: ...
    def extend(self, values: Iterable[_T]) -> None: ...
    def reverse(self) -> None: ...
    def pop(self, index: int = -1) -> _T: ...
    def remove(self, value: _T) -> None: ...

class AbstractSet(Collection[_T_co]):
    def __contains__(self, x: object) -> bool: ...
    def _hash(self) -> int: ...
    def __le__(self, other: AbstractSet[Any]) -> bool: ...
    def __lt__(self, other: AbstractSet[Any]) -> bool: ...
    def __gt__(self, other: AbstractSet[Any]) -> bool: ...
    def __ge__(self, other: AbstractSet[Any]) -> bool: ...
    def __and__(self, other: AbstractSet[Any]) -> AbstractSet[_T_co]: ...
    def __or__(self, other: AbstractSet[_T]) -> AbstractSet[_T_co | _T]: ...
    def __sub__(self, other: AbstractSet[Any]) -> AbstractSet[_T_co]: ...
    def __xor__(self, other: AbstractSet[_T]) -> AbstractSet[_T_co | _T]: ...
    def __eq__(self, other: object) -> bool: ...
    def isdisjoint(self, other: Iterable[Any]) -> bool: ...

class MutableSet(AbstractSet[_T]):
    def add(self, value: _T) -> None: ...
    def discard(self, value: _T) -> None: ...
    def clear(self) -> None: ...
    def pop(self) -> _T: ...
    def remove(self, value: _T) -> None: ...

class MappingView(Sized):
    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented
    def __len__(self) -> int: ...

class ItemsView(MappingView, AbstractSet[tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):
    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented
    def __and__(self, other: Iterable[Any]) -> set[tuple[_KT_co, _VT_co]]: ...
    def __rand__(self, other: Iterable[_T]) -> set[_T]: ...
    def __contains__(self, item: object) -> bool: ...
    def __iter__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...
    def __or__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...
    def __ror__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...
    def __sub__(self, other: Iterable[Any]) -> set[tuple[_KT_co, _VT_co]]: ...
    def __rsub__(self, other: Iterable[_T]) -> set[_T]: ...
    def __xor__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...
    def __rxor__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...

class KeysView(MappingView, AbstractSet[_KT_co]):
    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented
    def __and__(self, other: Iterable[Any]) -> set[_KT_co]: ...
    def __rand__(self, other: Iterable[_T]) -> set[_T]: ...
    def __contains__(self, key: object) -> bool: ...
    def __iter__(self) -> Iterator[_KT_co]: ...
    def __or__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...
    def __ror__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...
    def __sub__(self, other: Iterable[Any]) -> set[_KT_co]: ...
    def __rsub__(self, other: Iterable[_T]) -> set[_T]: ...
    def __xor__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...
    def __rxor__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...

class ValuesView(MappingView, Collection[_VT_co]):
    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented
    def __contains__(self, value: object) -> bool: ...
    def __iter__(self) -> Iterator[_VT_co]: ...

class Mapping(Collection[_KT], Generic[_KT, _VT_co]):
    def __getitem__(self, __key: _KT) -> _VT_co: ...
    @overload
    def get(self, __key: _KT) -> _VT_co | None: ...
    @overload
    def get(self, __key: _KT, default: _VT_co | _T) -> _VT_co | _T: ...
    def items(self) -> ItemsView[_KT, _VT_co]: ...
    def keys(self) -> KeysView[_KT]: ...
    def values(self) -> ValuesView[_VT_co]: ...
    def __contains__(self, __key: object) -> bool: ...
    def __eq__(self, __other: object) -> bool: ...

class MutableMapping(Mapping[_KT, _VT]):
    def __setitem__(self, __key: _KT, __value: _VT) -> None: ...
    def __delitem__(self, __key: _KT) -> None: ...
    def clear(self) -> None: ...
    @overload
    def pop(self, __key: _KT) -> _VT: ...
    @overload
    def pop(self, __key: _KT, default: _VT) -> _VT: ...
    @overload
    def pop(self, __key: _KT, default: _T) -> _VT | _T: ...
    def popitem(self) -> tuple[_KT, _VT]: ...
    @overload
    def setdefault(self: MutableMapping[_KT, _T | None], __key: _KT, __default: None = None) -> _T | None: ...
    @overload
    def setdefault(self, __key: _KT, __default: _VT) -> _VT: ...
    @overload
    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...
    @overload
    def update(self, __m: Iterable[tuple[_KT, _VT]], **kwargs: _VT) -> None: ...
    @overload
    def update(self, **kwargs: _VT) -> None: ...

TYPE_CHECKING: bool

class IO(Iterator[AnyStr]):
    @property
    def mode(self) -> str: ...
    @property
    def name(self) -> str | Any: ...
    def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...
    def fileno(self) -> int: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    def read(self, __n: int = -1) -> AnyStr: ...
    def readable(self) -> bool: ...
    def readline(self, __limit: int = -1) -> AnyStr: ...
    def readlines(self, __hint: int = -1) -> list[AnyStr]: ...
    def seek(self, __offset: int, __whence: int = 0) -> int: ...
    def seekable(self) -> bool: ...
    def tell(self) -> int: ...
    def truncate(self, __size: int | None = None) -> int: ...
    def writable(self) -> bool: ...
    def __next__(self) -> AnyStr: ...
    def __iter__(self) -> Iterator[AnyStr]: ...

class BinaryIO: ...

class TextIO:
    @property
    def buffer(self) -> BinaryIO: ...
    @property
    def encoding(self) -> str: ...
    @property
    def errors(self) -> str | None: ...
    @property
    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython
    @property
    def newlines(self) -> Any: ...  # None, str or tuple

ByteString = bytes

@overload
def cast(typ: Type[_T], val: Any) -> _T: ...
@overload
def cast(typ: str, val: Any) -> Any: ...
@overload
def cast(typ: object, val: Any) -> Any: ...

class NamedTuple(tuple[Any, ...]):
    _field_defaults: ClassVar[dict[str, Any]]
    _fields: ClassVar[tuple[str, ...]]
    @overload
    def __init__(self, __typename: str, __fields: Iterable[tuple[str, Any]]) -> None: ...
    @overload
    def __init__(self, __typename: str, __fields: None = None, **kwargs: Any) -> None: ...
    @classmethod
    def _make(cls, iterable: Iterable[Any]) -> NamedTuple: ...
    def _asdict(self) -> dict[str, Any]: ...
    def _replace(self, **kwargs: Any) -> NamedTuple: ...

class _TypedDict(Mapping[str, object]):
    __total__: ClassVar[bool]
    def setdefault(self, k: NoReturn, default: object) -> object: ...
    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]
    def update(self: _T, __m: _T) -> None: ...
    def __delitem__(self, k: NoReturn) -> None: ...
    def items(self) -> ItemsView[str, object]: ...
    def keys(self) -> KeysView[str]: ...
    def values(self) -> ValuesView[object]: ...

class ForwardRef:
    def __init__(self, arg: str, is_argument: bool = True, module: Any | None = None, *, is_class: bool = False) -> None: ...
    def _evaluate(
        self, globalns: dict[str, Any] | None, localns: dict[str, Any] | None, recursive_guard: AbstractSet[str]
    ) -> Any | None: ...
