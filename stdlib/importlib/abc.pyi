import types
from importlib.machinery import ModuleSpec
from typing import IO, Any, Iterator, Mapping, Protocol, Sequence, overload
from typing_extensions import Literal

class Loader:
    def load_module(self, fullname: str) -> types.ModuleType: ...
    def create_module(self, spec: ModuleSpec) -> types.ModuleType | None: ...
    # Not defined on the actual class for backwards-compatibility reasons,
    # but expected in new code.
    def exec_module(self, module: types.ModuleType) -> None: ...

class InspectLoader(Loader):
    def is_package(self, fullname: str) -> bool: ...
    def get_code(self, fullname: str) -> types.CodeType | None: ...
    def get_source(self, fullname: str) -> str | None: ...
    def exec_module(self, module: types.ModuleType) -> None: ...
    @staticmethod
    def source_to_code(data: str, path: str = "<string>") -> types.CodeType: ...

class ExecutionLoader(InspectLoader):
    def get_filename(self, fullname: str) -> str: ...

class SourceLoader(ExecutionLoader):
    def path_mtime(self, path: str) -> float: ...
    def set_data(self, path: str, data: bytes) -> None: ...
    def get_source(self, fullname: str) -> str | None: ...
    def path_stats(self, path: str) -> Mapping[str, Any]: ...

# Please keep in sync with sys._MetaPathFinder
class MetaPathFinder:
    def invalidate_caches(self) -> None: ...
    # Not defined on the actual class, but expected to exist.
    def find_spec(
        self, __fullname: str, __path: Sequence[str] | None, __target: types.ModuleType | None = ...
    ) -> ModuleSpec | None: ...

class PathEntryFinder:
    def invalidate_caches(self) -> None: ...
    # Not defined on the actual class, but expected to exist.
    def find_spec(self, fullname: str, target: types.ModuleType | None = ...) -> ModuleSpec | None: ...

class FileLoader(ExecutionLoader):
    def __init__(self, fullname: str, path: str) -> None: ...
    def get_data(self, path: str) -> bytes: ...
    def get_filename(self, name: str | None = None) -> str: ...
    def load_module(self, name: str | None = None) -> types.ModuleType: ...

class ResourceReader:
    def open_resource(self, resource: str) -> IO[bytes]: ...
    def resource_path(self, resource: str) -> str: ...
    def is_resource(self, path: str) -> bool: ...
    def contents(self) -> Iterator[str]: ...

class Traversable(Protocol):
    def is_dir(self) -> bool: ...
    def is_file(self) -> bool: ...
    def iterdir(self) -> Iterator[Traversable]: ...
    def joinpath(self, *descendants: str) -> Traversable: ...
    # The documentation and runtime protocol allows *args, **kwargs arguments,
    # but this would mean that all implementers would have to support them,
    # which is not the case.
    @overload
    def open(self, __mode: Literal["r", "w"] = "r", *, encoding: str | None = None, errors: str | None = None) -> IO[str]: ...
    @overload
    def open(self, __mode: Literal["rb", "wb"]) -> IO[bytes]: ...
    @property
    def name(self) -> str: ...
    def __truediv__(self, __child: str) -> Traversable: ...
    def read_bytes(self) -> bytes: ...
    def read_text(self, encoding: str | None = None) -> str: ...

class TraversableResources(ResourceReader):
    def files(self) -> Traversable: ...
    def open_resource(self, resource: str) -> IO[bytes]: ...
    def resource_path(self, resource: Any) -> str: ...
    def is_resource(self, path: str) -> bool: ...
    def contents(self) -> Iterator[str]: ...
