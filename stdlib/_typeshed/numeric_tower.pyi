from abc import ABCMeta, abstractmethod
from typing import Generic, Protocol, TypeAlias, TypeVar, overload, runtime_checkable

Self = TypeVar("Self")
_T_co = TypeVar("_T_co", covariant=True)
_T_contra = TypeVar("_T_contra", contravariant=True)
_DivT_co = TypeVar("_DivT_co", covariant=True)
_AbsT_co = TypeVar("_AbsT_co", covariant=True)

_NumericT_co0 = TypeVar("_NumericT_co0", bound=Numeric, covariant=True)
_NumericT_co1 = TypeVar("_NumericT_co1", bound=Numeric, covariant=True)
_NumericT_co2 = TypeVar("_NumericT_co2", bound=Numeric, covariant=True)

_ComplexT_co = TypeVar("_ComplexT_co", bound=Complex, covariant=True)
_RealT_co = TypeVar("_RealT_co", covariant=True, bound=Real)
_RationalT_co = TypeVar("_RationalT_co", bound=Rational, covariant=True)
_IntegralT_co = TypeVar("_IntegralT_co", covariant=True, bound=Integral)

###
### COMPARISON METHODS ###
###

@runtime_checkable
class SupportsDunderLT(Protocol[_T_contra]):
    @abstractmethod
    def __lt__(self, __other: _T_contra) -> bool: ...

@runtime_checkable
class SupportsDunderGT(Protocol[_T_contra]):
    @abstractmethod
    def __gt__(self, __other: _T_contra) -> bool: ...

@runtime_checkable
class SupportsDunderLE(Protocol[_T_contra]):
    @abstractmethod
    def __le__(self, __other: _T_contra) -> bool: ...

@runtime_checkable
class SupportsDunderGE(Protocol[_T_contra]):
    @abstractmethod
    def __ge__(self, __other: _T_contra) -> bool: ...

# A protocol, but not a runtime_checkable one
class SupportsAllComparisons(
    SupportsDunderLT[_T_contra],
    SupportsDunderGT[_T_contra],
    SupportsDunderLE[_T_contra],
    SupportsDunderGE[_T_contra],
    Protocol[_T_contra],
): ...

###
### BASIC ARITHMETIC METHODS
###

### ADDITION METHODS

@runtime_checkable
class SupportsAdd(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __add__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsRAdd(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __radd__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsAddition(SupportsAdd[_T_contra, _T_co], SupportsRAdd[_T_contra, _T_co], Protocol[_T_contra, _T_co]): ...

### SUBTRACTION METHODS

@runtime_checkable
class SupportsSub(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __sub__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsRSub(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rsub__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsSubtraction(SupportsSub[_T_contra, _T_co], SupportsRSub[_T_contra, _T_co], Protocol[_T_contra, _T_co]): ...

### MULTIPLICATION METHODS

@runtime_checkable
class SupportsMul(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __mul__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsRMul(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rmul__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsMultiplication(SupportsMul[_T_contra, _T_co], SupportsRMul[_T_contra, _T_co], Protocol[_T_contra, _T_co]): ...

### DIVISION METHODS

@runtime_checkable
class SupportsTrueDiv(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __truediv__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsRTrueDiv(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rtruediv__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsTrueDivision(SupportsTrueDiv[_T_contra, _T_co], SupportsRTrueDiv[_T_contra, _T_co], Protocol[_T_contra, _T_co]): ...

@runtime_checkable
class SupportsFloorDiv(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __floordiv__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsRFloorDiv(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rfloordiv__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsFloorDivision(
    SupportsFloorDiv[_T_contra, _T_co], SupportsRFloorDiv[_T_contra, _T_co], Protocol[_T_contra, _T_co]
): ...

SupportsDivision: TypeAlias = SupportsTrueDivision[_T_contra, _T_co] | SupportsFloorDivision[_T_contra, _T_co]

### MOD METHODS

@runtime_checkable
class SupportsMod(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __mod__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsRMod(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rmod__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsModulo(SupportsMod[_T_contra, _T_co], SupportsRMod[_T_contra, _T_co], Protocol[_T_contra, _T_co]): ...

### DIVMOD METHODS

@runtime_checkable
class SupportsDunderDivMod(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __divmod__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsDunderRDivMod(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rdivmod__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsDivMod(
    SupportsDunderDivMod[_T_contra, _T_co], SupportsDunderRDivMod[_T_contra, _T_co], Protocol[_T_contra, _T_co]
): ...

### SupportsArithmetic

# A protocol, but not a runtime_checkable one
class SupportsBasicArithmetic(
    SupportsAddition[_T_contra, _T_co],
    SupportsSubtraction[_T_contra, _T_co],
    SupportsMultiplication[_T_contra, _T_co],
    SupportsTrueDivision[_T_contra, _DivT_co],
    Protocol[_T_contra, _T_co, _DivT_co],
): ...

###
### BITWISE ARITHMETIC METHODS
###

### Lshift << methods

@runtime_checkable
class SupportsDunderLShift(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __lshift__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsDunderRLShift(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rlshift__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsLShift(
    SupportsDunderLShift[_T_contra, _T_co], SupportsDunderRLShift[_T_contra, _T_co], Protocol[_T_contra, _T_co]
): ...

### Rshift >> methods

@runtime_checkable
class SupportsDunderRShift(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rshift__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsDunderRRShift(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rlshift__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsRShift(
    SupportsDunderRShift[_T_contra, _T_co], SupportsDunderRRShift[_T_contra, _T_co], Protocol[_T_contra, _T_co]
): ...

### & methods

@runtime_checkable
class SupportsDunderAnd(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __and__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsDunderRAnd(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rand__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsAnd(SupportsDunderAnd[_T_contra, _T_co], SupportsDunderRAnd[_T_contra, _T_co], Protocol[_T_contra, _T_co]): ...

### | methods

@runtime_checkable
class SupportsDunderOr(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __or__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsDunderROr(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rand__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsOr(SupportsDunderOr[_T_contra, _T_co], SupportsDunderROr[_T_contra, _T_co], Protocol[_T_contra, _T_co]): ...

### ^ methods

@runtime_checkable
class SupportsDunderXOr(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __xor__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsDunderRXOr(Protocol[_T_contra, _T_co]):
    @abstractmethod
    def __rxor__(self, __x: _T_contra) -> _T_co: ...

@runtime_checkable
class SupportsXOr(SupportsDunderXOr[_T_contra, _T_co], SupportsDunderRXOr[_T_contra, _T_co], Protocol[_T_contra, _T_co]): ...

### SupportsBitwiseArithmetic

# A protocol, but not a runtime-checkable one
class SupportsBitwiseArithmetic(
    SupportsLShift[_T_contra, _T_co],
    SupportsRShift[_T_contra, _T_co],
    SupportsAnd[_T_contra, _T_co],
    SupportsOr[_T_contra, _T_co],
    SupportsXOr[_T_contra, _T_co],
    Protocol[_T_contra, _T_co],
): ...

###
### UnOp numeric methods
###

@runtime_checkable
class SupportsAbs(Protocol[_T_co]):
    @abstractmethod
    def __abs__(self) -> _T_co: ...

@runtime_checkable
class SupportsPos(Protocol):
    @abstractmethod
    def __pos__(self: Self) -> Self: ...

@runtime_checkable
class SupportsNeg(Protocol):
    @abstractmethod
    def __neg__(self: Self) -> Self: ...

@runtime_checkable
class SupportsInversion(Protocol[_T_co]):
    @abstractmethod
    def __invert__(self) -> _T_co: ...

###
### Numeric coercion methods
###

@runtime_checkable
class SupportsInt(Protocol):
    @abstractmethod
    def __int__(self) -> int: ...

@runtime_checkable
class SupportsFloat(Protocol):
    @abstractmethod
    def __float__(self) -> float: ...

@runtime_checkable
class SupportsComplex(Protocol):
    @abstractmethod
    def __complex__(self) -> complex: ...

@runtime_checkable
class SupportsIndex(Protocol):
    @abstractmethod
    def __index__(self) -> int: ...

###
### Rounding methods
###

@runtime_checkable
class SupportsRound(Protocol[_RealT_co]):
    @abstractmethod
    @overload
    def __round__(self, __ndigits: None = ...) -> Integral: ...
    @abstractmethod
    @overload
    def __round__(self, __ndigits: int) -> _RealT_co: ...

@runtime_checkable
class SupportsTrunc(Protocol[_IntegralT_co]):
    @abstractmethod
    def __trunc__(self) -> _IntegralT_co: ...

@runtime_checkable
class SupportsFloor(Protocol[_IntegralT_co]):
    @abstractmethod
    def __floor__(self) -> _IntegralT_co: ...

@runtime_checkable
class SupportsCeil(Protocol[_IntegralT_co]):
    @abstractmethod
    def __ceil__(self) -> _IntegralT_co: ...

# A protocol, but not a runtime-checkable one
class SupportsAllRounding(
    SupportsRound[_RealT_co],
    SupportsTrunc[_IntegralT_co],
    SupportsFloor[_IntegralT_co],
    SupportsCeil[_IntegralT_co],
    Protocol[_RealT_co, _IntegralT_co],
): ...

###
### One-offs
###

@runtime_checkable
class HasNumeratorAndDenominator(Protocol[_IntegralT_co]):
    @property
    @abstractmethod
    def numerator(self) -> _IntegralT_co: ...
    @property
    @abstractmethod
    def denominator(self) -> _IntegralT_co: ...

SupportsCoercionToInt: TypeAlias = SupportsInt | SupportsIndex | SupportsTrunc

###
### The big ABCs
### N.B. NOT protocols
###

class Numeric(
    SupportsBasicArithmetic[_NumericT_co0, _NumericT_co0, _NumericT_co1],
    SupportsAbs[_AbsT_co],
    SupportsPos,
    SupportsNeg,
    Generic[_NumericT_co0, _NumericT_co1, _AbsT_co],
    metaclass=ABCMeta,
):
    """
    Numeric[<SupportedArithmeticType>, <ResultOfTrueDiv>, <ResultOfAbs>]

    Generic ABC for all number-like classes.

    Inherited abstract methods:
    - __add__/__radd__
    - __sub__/__rsub__
    - __mul__/__rmul__
    - __truediv__/__rtruediv__
    - __abs__
    - __eq__/__ne__
    - __pos__
    - __neg__

    Abstract methods defined here:
    - __bool__
    - __hash__
    """
    @abstractmethod
    def __bool__(self) -> bool: ...
    @abstractmethod
    def __hash__(self) -> int: ...

class Complex(
    Numeric[_ComplexT_co, _ComplexT_co, _AbsT_co],
    SupportsComplex,
    Generic[_ComplexT_co, _AbsT_co, _RealT_co],
    metaclass=ABCMeta,
):
    """
    Complex[<SupportedArithmeticType>, <ResultOfAbs>, <TypeOfRealImag>]

    An interface for classes emulating "complex" numeric types.

    Inherited abstract methods from Numeric:
    - __add__/__radd__
    - __sub__/__rsub__
    - __mul__/__rmul__
    - __truediv__/__rtruediv__
    - __abs__
    - __eq__/__ne__
    - __pos__
    - __neg__
    - __bool__
    - __hash__

    Inherited abstract methods from other mixins:
    - __complex__

    Abstract methods defined here:
    - conjugate

    Abstract properties defined here:
    - real
    - imag
    """
    @property
    @abstractmethod
    def real(self) -> _RealT_co: ...
    @property
    @abstractmethod
    def imag(self) -> _RealT_co: ...
    @abstractmethod
    def conjugate(self: Self) -> Self: ...

class Real(
    Numeric[_RealT_co, _NumericT_co1, _RealT_co],
    SupportsFloorDivision[_RealT_co, _NumericT_co2],
    SupportsModulo[_RealT_co, _RealT_co],
    SupportsAllRounding[_RealT_co, _IntegralT_co],
    SupportsAllComparisons[_RealT_co],
    Generic[_RealT_co, _NumericT_co1, _NumericT_co2, _IntegralT_co],
    metaclass=ABCMeta,
):
    """
    class Real[<SupportedArithmeticType>, <ResultOfTrueDiv>, <ResultOfFloorDiv> <ResultOfRounding>]

    An interface for classes emulating "real" numeric types.

    Inherited abstract methods from Numeric:
    - __add__/__radd__
    - __sub__/__rsub__
    - __mul__/__rmul__
    - __truediv__/__rtruediv__
    - __abs__
    - __eq__/__ne__
    - __pos__
    - __neg__
    - __bool__
    - __hash__

    Inherited abstract methods from other mixins:
    - __floordiv__
    - __mod__
    - __round__
    - __trunc__
    - __ceil__
    - __floor__
    - __lt__
    - __le__
    - __gt__
    - __ge__
    """

class Rational(
    Real[_RationalT_co, _NumericT_co1, _NumericT_co2, _IntegralT_co],
    HasNumeratorAndDenominator[_IntegralT_co],
    Generic[_RationalT_co, _NumericT_co1, _NumericT_co2, _IntegralT_co],
    metaclass=ABCMeta,
):
    """
    class Rational[<SupportedArithmeticType>, <ResultOfTrueDiv>, <ResultOfFloorDiv>, <ResultOfRounding>]

    An interface for classes emulating "rational" numeric types.

    Inherited abstract methods from Real:
    - __add__/__radd__
    - __sub__/__rsub__
    - __mul__/__rmul__
    - __truediv__/__rtruediv__
    - __abs__
    - __eq__/__ne__
    - __pos__
    - __neg__
    - __bool__
    - __hash__
    - __floordiv__
    - __round__
    - __trunc__
    - __ceil__
    - __floor__
    - __lt__
    - __le__
    - __gt__
    - __ge__

    Abstract properties from other mixins:
    - denominator
    - numerator
    """

class Integral(
    Real[_IntegralT_co, _NumericT_co1, _IntegralT_co, _IntegralT_co],
    SupportsBitwiseArithmetic[_IntegralT_co, _IntegralT_co],
    HasNumeratorAndDenominator[_IntegralT_co],
    SupportsInversion[_IntegralT_co],
    SupportsIndex,
    SupportsInt,
    SupportsFloat,
    Generic[_IntegralT_co, _NumericT_co1],
    metaclass=ABCMeta,
):
    """
    class Integral[<SupportedArithmeticType>, <ResultOfTrueDiv>,]

    An interface for classes emulating "rational" numeric types.

    Inherited abstract methods from Real:
    - __add__/__radd__
    - __sub__/__rsub__
    - __mul__/__rmul__
    - __truediv__/__rtruediv__
    - __abs__
    - __eq__/__ne__
    - __pos__
    - __neg__
    - __bool__
    - __hash__
    - __floordiv__
    - __round__
    - __trunc__
    - __ceil__
    - __floor__
    - __lt__
    - __le__
    - __gt__
    - __ge__

    Abstract methods inherited from other mixins:
    - __or__/__ror__
    - __and__/__rand__
    - __xor__/__rxor__
    - __lshift__/__rlshift__
    - __rshift__/__rrshift__
    - __invert__
    - __index__
    - __int__
    - __float__

    Abstract properties from other mixins:
    - denominator
    - numerator
    """

###
### TYPESHED STUBS FOR RUNTIME CLASSES
###

import sys
from _typeshed import ReadableBuffer
from decimal import DecimalTuple, Context
from typing import Any, Callable, Iterable, Literal, NoReturn, Sequence, SupportsBytes, Union

_PositiveInteger: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
_NegativeInteger: TypeAlias = Literal[-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20]

class int(Integral[int, float]):
    @overload
    def __new__(cls: type[Self], __x: str | ReadableBuffer | SupportsCoercionToInt = ...) -> Self: ...
    @overload
    def __new__(cls: type[Self], __x: str | bytes | bytearray, base: SupportsIndex) -> Self: ...
    if sys.version_info >= (3, 8):
        def as_integer_ratio(self) -> tuple[int, Literal[1]]: ...

    @property
    def real(self) -> int: ...
    @property
    def imag(self) -> int: ...
    @property
    def numerator(self) -> int: ...
    @property
    def denominator(self) -> int: ...
    def conjugate(self) -> int: ...
    def bit_length(self) -> int: ...
    if sys.version_info >= (3, 10):
        def bit_count(self) -> int: ...

    if sys.version_info >= (3, 11):
        def to_bytes(
            self, length: SupportsIndex = ..., byteorder: Literal["little", "big"] = ..., *, signed: bool = ...
        ) -> bytes: ...
        @classmethod
        def from_bytes(
            cls: type[Self],
            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,
            byteorder: Literal["little", "big"] = ...,
            *,
            signed: bool = ...,
        ) -> Self: ...
    else:
        def to_bytes(self, length: SupportsIndex, byteorder: Literal["little", "big"], *, signed: bool = ...) -> bytes: ...
        @classmethod
        def from_bytes(
            cls: type[Self],
            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,
            byteorder: Literal["little", "big"],
            *,
            signed: bool = ...,
        ) -> Self: ...

    def __add__(self, __x: int) -> int: ...
    def __sub__(self, __x: int) -> int: ...
    def __mul__(self, __x: int) -> int: ...
    def __floordiv__(self, __x: int) -> int: ...
    def __truediv__(self, __x: int) -> float: ...
    def __mod__(self, __x: int) -> int: ...
    def __divmod__(self, __x: int) -> tuple[int, int]: ...
    def __radd__(self, __x: int) -> int: ...
    def __rsub__(self, __x: int) -> int: ...
    def __rmul__(self, __x: int) -> int: ...
    def __rfloordiv__(self, __x: int) -> int: ...
    def __rtruediv__(self, __x: int) -> float: ...
    def __rmod__(self, __x: int) -> int: ...
    def __rdivmod__(self, __x: int) -> tuple[int, int]: ...
    @overload
    def __pow__(self, __x: Literal[0]) -> Literal[1]: ...
    @overload
    def __pow__(self, __x: Literal[0], __modulo: None) -> Literal[1]: ...
    @overload
    def __pow__(self, __x: _PositiveInteger, __modulo: None = ...) -> int: ...
    @overload
    def __pow__(self, __x: _NegativeInteger, __modulo: None = ...) -> float: ...
    @overload
    def __pow__(self, __x: int, __modulo: None = ...) -> Any: ...
    @overload
    def __pow__(self, __x: int, __modulo: Literal[0]) -> NoReturn: ...
    @overload
    def __pow__(self, __x: int, __modulo: int) -> int: ...
    def __rpow__(self, __x: int, __mod: int | None = ...) -> Any: ...
    def __and__(self, __n: int) -> int: ...
    def __or__(self, __n: int) -> int: ...
    def __xor__(self, __n: int) -> int: ...
    def __lshift__(self, __n: int) -> int: ...
    def __rshift__(self, __n: int) -> int: ...
    def __rand__(self, __n: int) -> int: ...
    def __ror__(self, __n: int) -> int: ...
    def __rxor__(self, __n: int) -> int: ...
    def __rlshift__(self, __n: int) -> int: ...
    def __rrshift__(self, __n: int) -> int: ...
    def __neg__(self) -> int: ...
    def __pos__(self) -> int: ...
    def __invert__(self) -> int: ...
    def __trunc__(self) -> int: ...
    def __ceil__(self) -> int: ...
    def __floor__(self) -> int: ...
    # Doesn't actually take a second argument, but hey
    def __round__(self, __ndigits: SupportsIndex | None = ...) -> int: ...
    def __getnewargs__(self) -> tuple[int]: ...
    def __eq__(self, __x: object) -> bool: ...
    def __ne__(self, __x: object) -> bool: ...
    def __lt__(self, __x: int) -> bool: ...
    def __le__(self, __x: int) -> bool: ...
    def __gt__(self, __x: int) -> bool: ...
    def __ge__(self, __x: int) -> bool: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __abs__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __index__(self) -> int: ...

class float(Real[float, float, float, int]):
    def __new__(cls: type[Self], x: SupportsFloat | SupportsIndex | str | ReadableBuffer = ...) -> Self: ...
    def as_integer_ratio(self) -> tuple[int, int]: ...
    def hex(self) -> str: ...
    def is_integer(self) -> bool: ...
    @classmethod
    def fromhex(cls: type[Self], __s: str) -> Self: ...
    @property
    def real(self) -> float: ...
    @property
    def imag(self) -> float: ...
    def conjugate(self) -> float: ...
    def __add__(self, __x: float) -> float: ...
    def __sub__(self, __x: float) -> float: ...
    def __mul__(self, __x: float) -> float: ...
    def __floordiv__(self, __x: float) -> float: ...
    def __truediv__(self, __x: float) -> float: ...
    def __mod__(self, __x: float) -> float: ...
    def __divmod__(self, __x: float) -> tuple[float, float]: ...
    @overload
    def __pow__(self, __x: int, __mod: None = ...) -> float: ...
    @overload
    def __pow__(self, __x: float, __mod: None = ...) -> Any: ...
    def __radd__(self, __x: float) -> float: ...
    def __rsub__(self, __x: float) -> float: ...
    def __rmul__(self, __x: float) -> float: ...
    def __rfloordiv__(self, __x: float) -> float: ...
    def __rtruediv__(self, __x: float) -> float: ...
    def __rmod__(self, __x: float) -> float: ...
    def __rdivmod__(self, __x: float) -> tuple[float, float]: ...
    @overload
    def __rpow__(self, __x: _PositiveInteger, __modulo: None = ...) -> float: ...
    @overload
    def __rpow__(self, __x: _NegativeInteger, __mod: None = ...) -> complex: ...
    @overload
    def __rpow__(self, __x: float, __mod: None = ...) -> Any: ...
    def __getnewargs__(self) -> tuple[float]: ...
    def __trunc__(self) -> int: ...

    # These two actually only exist on 3.9+, but hey
    def __ceil__(self) -> int: ...
    def __floor__(self) -> int: ...
    @overload
    def __round__(self, __ndigits: None = ...) -> int: ...
    @overload
    def __round__(self, __ndigits: SupportsIndex) -> float: ...
    def __eq__(self, __x: object) -> bool: ...
    def __ne__(self, __x: object) -> bool: ...
    def __lt__(self, __x: float) -> bool: ...
    def __le__(self, __x: float) -> bool: ...
    def __gt__(self, __x: float) -> bool: ...
    def __ge__(self, __x: float) -> bool: ...
    def __neg__(self) -> float: ...
    def __pos__(self) -> float: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __abs__(self) -> float: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...

class complex(Complex[complex, float, float]):
    @overload
    def __new__(cls: type[Self], real: float = ..., imag: float = ...) -> Self: ...
    @overload
    def __new__(cls: type[Self], real: str | SupportsComplex | SupportsIndex) -> Self: ...
    @property
    def real(self) -> float: ...
    @property
    def imag(self) -> float: ...
    def conjugate(self) -> complex: ...
    def __add__(self, __x: complex) -> complex: ...
    def __sub__(self, __x: complex) -> complex: ...
    def __mul__(self, __x: complex) -> complex: ...
    def __pow__(self, __x: complex, __mod: None = ...) -> complex: ...
    def __truediv__(self, __x: complex) -> complex: ...
    def __radd__(self, __x: complex) -> complex: ...
    def __rsub__(self, __x: complex) -> complex: ...
    def __rmul__(self, __x: complex) -> complex: ...
    def __rpow__(self, __x: complex, __mod: None = ...) -> complex: ...
    def __rtruediv__(self, __x: complex) -> complex: ...
    def __eq__(self, __x: object) -> bool: ...
    def __ne__(self, __x: object) -> bool: ...
    def __neg__(self) -> complex: ...
    def __pos__(self) -> complex: ...
    def __abs__(self) -> float: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
    # Actually only exists on 3.11+, but this is probably an acceptable lie
    def __complex__(self) -> complex: ...

_DecimalComparableNum: TypeAlias = Decimal | int | float | Rational
_Decimal: TypeAlias = Decimal | int
_DecimalNew: TypeAlias = Union[Decimal, float, str, tuple[int, Sequence[int], int]]

class Decimal(Real[Decimal | int, Decimal, Decimal, int]):
    def __new__(cls: type[Self], value: _DecimalNew = ..., context: Context | None = ...) -> Self: ...
    @classmethod
    def from_float(cls: type[Self], __f: float) -> Self: ...
    def __bool__(self) -> bool: ...
    def compare(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def __hash__(self) -> int: ...
    def as_tuple(self) -> DecimalTuple: ...
    def as_integer_ratio(self) -> tuple[int, int]: ...
    def to_eng_string(self, context: Context | None = ...) -> str: ...
    def __abs__(self) -> Decimal: ...
    def __add__(self, __other: _Decimal) -> Decimal: ...
    def __divmod__(self, __other: _Decimal) -> tuple[Decimal, Decimal]: ...
    def __eq__(self, __other: object) -> bool: ...
    def __floordiv__(self, __other: _Decimal) -> Decimal: ...
    def __ge__(self, __other: _DecimalComparableNum) -> bool: ...
    def __gt__(self, __other: _DecimalComparableNum) -> bool: ...
    def __le__(self, __other: _DecimalComparableNum) -> bool: ...
    def __lt__(self, __other: _DecimalComparableNum) -> bool: ...
    def __mod__(self, __other: _Decimal) -> Decimal: ...
    def __mul__(self, __other: _Decimal) -> Decimal: ...
    def __neg__(self) -> Decimal: ...
    def __pos__(self) -> Decimal: ...
    def __pow__(self, __other: _Decimal, __modulo: _Decimal | None = ...) -> Decimal: ...
    def __radd__(self, __other: _Decimal) -> Decimal: ...
    def __rdivmod__(self, __other: _Decimal) -> tuple[Decimal, Decimal]: ...
    def __rfloordiv__(self, __other: _Decimal) -> Decimal: ...
    def __rmod__(self, __other: _Decimal) -> Decimal: ...
    def __rmul__(self, __other: _Decimal) -> Decimal: ...
    def __rsub__(self, __other: _Decimal) -> Decimal: ...
    def __rtruediv__(self, __other: _Decimal) -> Decimal: ...
    def __sub__(self, __other: _Decimal) -> Decimal: ...
    def __truediv__(self, __other: _Decimal) -> Decimal: ...
    def remainder_near(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __trunc__(self) -> int: ...
    @property
    def real(self) -> Decimal: ...
    @property
    def imag(self) -> Decimal: ...
    def conjugate(self) -> Decimal: ...
    def __complex__(self) -> complex: ...
    @overload  # type: ignore[override]
    def __round__(self) -> int: ...
    @overload
    def __round__(self, __ndigits: int) -> Decimal: ...
    def __floor__(self) -> int: ...
    def __ceil__(self) -> int: ...
    def fma(self, other: _Decimal, third: _Decimal, context: Context | None = ...) -> Decimal: ...
    def __rpow__(self, __other: _Decimal, __context: Context | None = ...) -> Decimal: ...
    def normalize(self, context: Context | None = ...) -> Decimal: ...
    def quantize(self, exp: _Decimal, rounding: str | None = ..., context: Context | None = ...) -> Decimal: ...
    def same_quantum(self, other: _Decimal, context: Context | None = ...) -> bool: ...
    def to_integral_exact(self, rounding: str | None = ..., context: Context | None = ...) -> Decimal: ...
    def to_integral_value(self, rounding: str | None = ..., context: Context | None = ...) -> Decimal: ...
    def to_integral(self, rounding: str | None = ..., context: Context | None = ...) -> Decimal: ...
    def sqrt(self, context: Context | None = ...) -> Decimal: ...
    def max(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def min(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def adjusted(self) -> int: ...
    def canonical(self) -> Decimal: ...
    def compare_signal(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def compare_total(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def compare_total_mag(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def copy_abs(self) -> Decimal: ...
    def copy_negate(self) -> Decimal: ...
    def copy_sign(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def exp(self, context: Context | None = ...) -> Decimal: ...
    def is_canonical(self) -> bool: ...
    def is_finite(self) -> bool: ...
    def is_infinite(self) -> bool: ...
    def is_nan(self) -> bool: ...
    def is_normal(self, context: Context | None = ...) -> bool: ...
    def is_qnan(self) -> bool: ...
    def is_signed(self) -> bool: ...
    def is_snan(self) -> bool: ...
    def is_subnormal(self, context: Context | None = ...) -> bool: ...
    def is_zero(self) -> bool: ...
    def ln(self, context: Context | None = ...) -> Decimal: ...
    def log10(self, context: Context | None = ...) -> Decimal: ...
    def logb(self, context: Context | None = ...) -> Decimal: ...
    def logical_and(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def logical_invert(self, context: Context | None = ...) -> Decimal: ...
    def logical_or(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def logical_xor(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def max_mag(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def min_mag(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def next_minus(self, context: Context | None = ...) -> Decimal: ...
    def next_plus(self, context: Context | None = ...) -> Decimal: ...
    def next_toward(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def number_class(self, context: Context | None = ...) -> str: ...
    def radix(self) -> Decimal: ...
    def rotate(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def scaleb(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def shift(self, other: _Decimal, context: Context | None = ...) -> Decimal: ...
    def __reduce__(self: Self) -> tuple[type[Self], tuple[str]]: ...
    def __copy__(self: Self) -> Self: ...
    def __deepcopy__(self: Self, __memo: Any) -> Self: ...
    def __format__(self, __specifier: str, __context: Context | None = ...) -> str: ...

_FractionComparableNum: TypeAlias = int | float | Decimal | Real

class Fraction(Rational):
    @overload
    def __new__(
        cls: type[Self], numerator: int | Rational = ..., denominator: int | Rational | None = ..., *, _normalize: bool = ...
    ) -> Self: ...
    @overload
    def __new__(cls: type[Self], __value: float | Decimal | str, *, _normalize: bool = ...) -> Self: ...
    @classmethod
    def from_float(cls: type[Self], f: float) -> Self: ...
    @classmethod
    def from_decimal(cls: type[Self], dec: Decimal) -> Self: ...
    def limit_denominator(self, max_denominator: int = ...) -> Fraction: ...
    if sys.version_info >= (3, 8):
        def as_integer_ratio(self) -> tuple[int, int]: ...

    @property
    def numerator(self) -> int: ...
    @property
    def denominator(self) -> int: ...
    @overload
    def __add__(self, b: int | Fraction) -> Fraction: ...
    @overload
    def __add__(self, b: float) -> float: ...
    @overload
    def __add__(self, b: complex) -> complex: ...
    @overload
    def __radd__(self, a: int | Fraction) -> Fraction: ...
    @overload
    def __radd__(self, a: float) -> float: ...
    @overload
    def __radd__(self, a: complex) -> complex: ...
    @overload
    def __sub__(self, b: int | Fraction) -> Fraction: ...
    @overload
    def __sub__(self, b: float) -> float: ...
    @overload
    def __sub__(self, b: complex) -> complex: ...
    @overload
    def __rsub__(self, a: int | Fraction) -> Fraction: ...
    @overload
    def __rsub__(self, a: float) -> float: ...
    @overload
    def __rsub__(self, a: complex) -> complex: ...
    @overload
    def __mul__(self, b: int | Fraction) -> Fraction: ...
    @overload
    def __mul__(self, b: float) -> float: ...
    @overload
    def __mul__(self, b: complex) -> complex: ...
    @overload
    def __rmul__(self, a: int | Fraction) -> Fraction: ...
    @overload
    def __rmul__(self, a: float) -> float: ...
    @overload
    def __rmul__(self, a: complex) -> complex: ...
    @overload
    def __truediv__(self, b: int | Fraction) -> Fraction: ...
    @overload
    def __truediv__(self, b: float) -> float: ...
    @overload
    def __truediv__(self, b: complex) -> complex: ...
    @overload
    def __rtruediv__(self, a: int | Fraction) -> Fraction: ...
    @overload
    def __rtruediv__(self, a: float) -> float: ...
    @overload
    def __rtruediv__(self, a: complex) -> complex: ...
    @overload
    def __floordiv__(self, b: int | Fraction) -> int: ...
    @overload
    def __floordiv__(self, b: float) -> float: ...
    @overload
    def __rfloordiv__(self, a: int | Fraction) -> int: ...
    @overload
    def __rfloordiv__(self, a: float) -> float: ...
    @overload
    def __mod__(self, b: int | Fraction) -> Fraction: ...
    @overload
    def __mod__(self, b: float) -> float: ...
    @overload
    def __rmod__(self, a: int | Fraction) -> Fraction: ...
    @overload
    def __rmod__(self, a: float) -> float: ...
    @overload
    def __divmod__(self, b: int | Fraction) -> tuple[int, Fraction]: ...
    @overload
    def __divmod__(self, b: float) -> tuple[float, Fraction]: ...
    @overload
    def __rdivmod__(self, a: int | Fraction) -> tuple[int, Fraction]: ...
    @overload
    def __rdivmod__(self, a: float) -> tuple[float, Fraction]: ...
    @overload
    def __pow__(self, b: int) -> Fraction: ...
    @overload
    def __pow__(self, b: float | Fraction) -> float: ...
    @overload
    def __pow__(self, b: complex) -> complex: ...
    @overload
    def __rpow__(self, a: float | Fraction) -> float: ...
    @overload
    def __rpow__(self, a: complex) -> complex: ...
    def __pos__(self) -> Fraction: ...
    def __neg__(self) -> Fraction: ...
    def __abs__(self) -> Fraction: ...
    def __trunc__(self) -> int: ...
    def __floor__(self) -> int: ...
    def __ceil__(self) -> int: ...
    @overload
    def __round__(self, ndigits: None = ...) -> int: ...
    @overload
    def __round__(self, ndigits: int) -> Fraction: ...
    def __hash__(self) -> int: ...
    def __eq__(self, b: object) -> bool: ...
    def __lt__(self, b: _FractionComparableNum) -> bool: ...
    def __gt__(self, b: _FractionComparableNum) -> bool: ...
    def __le__(self, b: _FractionComparableNum) -> bool: ...
    def __ge__(self, b: _FractionComparableNum) -> bool: ...
    def __bool__(self) -> bool: ...
    def __copy__(self: Self) -> Self: ...
    def __deepcopy__(self: Self, memo: Any) -> Self: ...
    # Actually only defined on 3.11+, but hey
    def __int__(self, _index: Callable[[SupportsIndex], int] = ...) -> int: ...
    # Not actually defined within fractions.py, but provides more useful
    # overrides
    @property
    def real(self) -> Fraction: ...
    @property
    def imag(self) -> Literal[0]: ...
    def conjugate(self) -> Fraction: ...
